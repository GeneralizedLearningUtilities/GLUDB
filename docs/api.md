
# Package gludb

glubdb - A simple database wrapper

## Package gludb.backends

glubdb.backends - implementation of actual db backends

### module gludb.backends.dynamodb (in pkg gludb.backends)

gludb.backends.dynamodb - backend dynamodb database module

#### class Backend

None

##### function  `__init__`

 | (self, **kwrds)


##### function  `ensure_table`

 | (self, cls)


##### function  `find_all`

 | (self, cls)


##### function  `find_by_index`

 | (self, cls, index_name, value)


##### function  `find_one`

 | (self, cls, id)


##### function  `get_class_table`

 | (self, cls)
Return a DynamoDB table object for the given class


##### function  `save`

 | (self, obj)


##### function  `table_schema_call`

 | (self, target, cls)
Call the callable target with the args and keywords needed for the
table defined by cls. This is how we centralize the Table.create and
Table ctor calls



#### class DynamoMappings

DynamoDB has some opinions about what you can store or query in an
attribute. We're going to use mappings to fix that.

#####  `EMPTY_STR_VAL`

str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.


#####  `NONE_VAL`

str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.


#####  `__init__`

Initialize self.  See help(type(self)) for accurate signature.


##### function  `map_index_val`

 | (index_val)
Xform index_val so that it can be stored/queried


##### function  `unmap_stored_val`

 | (stored_val)
Inverse of index_val_mapping. Note that we currently don't use it
because we don't actually read back index values (since they are
generated by Python functions)



#### function `delete_table`

Mainly for testing


#### function `get_conn`

Return a connection to DynamoDB (and handle local/debug
possibilities)


#### function `gsi_name`

Standardize how we create a GSI name for DynamoDB from the given index
name from the class


#### function `uuid`

None


#### function `uuid4`

Generate a random UUID.



### module gludb.backends.sqlite (in pkg gludb.backends)

gludb.backends.sqlite - backend sqlite database module

#### class Backend

None

##### function  `__init__`

 | (self, **kwrds)


##### function  `ensure_table`

 | (self, cls)


##### function  `find_all`

 | (self, cls)


##### function  `find_by_index`

 | (self, cls, index_name, value)


##### function  `find_one`

 | (self, cls, id)


##### function  `save`

 | (self, obj)



#### function `uuid`

None


#### function `uuid4`

Generate a random UUID.




## module gludb.config (in pkg gludb)

gludb.config

Provide gludb configuration. This consists mainly of a mapping from Storable
classes to a database configuration. It also includes a default mapping for
classes not specifically mapped to a database.

We check for a mapping for a class in MRO (Method Resolution Order). Suppose
a class Busy derives from the three classes X, Y, and Z - all of which derive
from class Base:

    class Base(object):
        pass

    class X(Base):
        pass
    class Y(Base):
        pass
    class Z(Base):
        pass

    class Busy(X, Y, Z):
        pass

Then a check for mapping would first checking for class Busy, then (in order)
classes X, Y, Z, Base, and object. If this is the first time you've seen
multiple inheritance, you'll note that the order of Busy's super classes is
important. This is how Python resolves method calls (we didn't just make this
up). In fact, we depend on the results of the standard library call
`inspect.getmro`.

If none of the classes mentioned have a mapping, then the default mapping will
be used. If there is no default mapping, then the class can't be mapped to a
database instance and an error will be thrown.

Astute readers will note that you could map the class `object` to a database
as a kind of default mapping. We generally don't recommend this, because it
would work *sort of*. Some notes:

* Recall that we support Python 2 and 3. In Python 3.4, classes declared
  without a base class get `object` as a base class automatically. In Python
  2.7 they just don't have a base class. That means that using an `object`
  DB mapping won't work as a default in every case.
* We always check for the default database mapping last, so mapping to object
  would be the last thing checked before the actual default.

### class Database

Configuration class representing a database instance supported by one
of our backends

#### function  `__init__`

 | (self, db_driver, **kwrds)


#### function  `ensure_table`

 | (self, cls)


#### function  `find_all`

 | (self, cls)


#### function  `find_by_index`

 | (self, cls, index_name, value)


#### function  `find_one`

 | (self, cls, id)


#### function  `save`

 | (self, obj)



### function `class_database`

Map a class (for which we assume issubclass(cls, Storable)==True) to
a database configuration


### function `clear_database_config`

Reset all mappings to default state. Note that any in-memory databases
will be lost


### function `default_database`

Set the default database configuration used for classes without a
specific mapping


### function `get_mapping`

Return a database config object for the given class


### function `getmro`

Return tuple of base classes (including cls) in method resolution order.


### function `import_module`

Import a module.

The 'package' argument is required when performing a relative import. It
specifies the package to use as the anchor point from which to resolve the
relative import to an absolute import.



## module gludb.data (in pkg gludb)

gludb.data

The "core" functionality. If you're unsure what to use, you should look into
gludb.simple. This module is for those needing advanced functionality or
customization

### function `DatabaseEnabled`

Classes annotated with DatabaseEnabled gain persistence methods. All
this really does is add some functions that forward to the mapped database
class


### class Storable

Our abstract base class that marks subclasses as persistable and
storable. Note that the DBObject annotation in gludb.simple registers
all annotated classes as 'virtual base classes' of Storage so that you
can test them with isinstance(obj, Storable)

####  `ORIG_VER_FIELD_NAME`

str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.


####  `__init__`

Initialize self.  See help(type(self)) for accurate signature.


####  `from_data`

This classmethod returns a new instance of the subclass populated
from the JSON representation


#### function  `get_id`

 | (self)
The instance should return the current key/ID for the instance. If
a 'falsey' value is return, on save one will be created and set via a
call to self.set_id


####  `get_table_name`

Return the name of the table/collection/etc where objects should
be saved/loaded


####  `get_versioning`

Return the type of versioning to be used - should be one of the
values defined in gludb.versioning


####  `index_names`

This optional method should return an iterable of index names. These
names should correspond to the names used in the dictionary returned by
the instance method `indexes` (below)


#### function  `indexes`

 | (self)
This optional method should return a dictionary of index name values
that can be used in a query. Note that this is not considered required
data, so a backend could ignore indexes if necessary.


#### function  `set_id`

 | (self, new_id)
The instance should accept a new key/ID. See also get_id


#### function  `to_data`

 | (self)
The instance should return JSON representation of it's internal
state. See also from_data



### function `abstractmethod`

A decorator indicating abstract methods.

Requires that the metaclass is ABCMeta or derived from it.  A
class that has a metaclass derived from ABCMeta cannot be
instantiated unless all of its abstract methods are overridden.
The abstract methods can be called using any of the normal
'super' call mechanisms.

Usage:

    class C(metaclass=ABCMeta):
        @abstractmethod
        def my_abstract_method(self, ...):
            ...


### function `get_mapping`

Return a database config object for the given class


### function `orig_version`

Return the original version of an object (defined as what was read from
the database before any user edits). If there isn't a previous version (for
instance, newly created objects don't have a previous version), then None
is returned. Mainly useful for testing


### function `record_diff`

Return a JSON-compatible structure capable turn the `new` record back
into the `old` record. The parameters must be structures compatible with
json.dumps *or* strings compatible with json.loads. Note that by design,
`old == record_patch(new, record_diff(old, new))`



## module gludb.simple (in pkg gludb)

gludb.simple

Provides the simplest possible interface to our functionality.

We provide a simple annotation to create classes with fields (with optional
default values), parameterized constructors, persistence, and data operations.
You are free to derive from any object you wish. See gludb.data if you need
custom or more advanced functionality.

    @DBObject
    class Demo(object):
        some_field = Field()
        my_number = Field(default=42)


    d = Demo(some_field='foo', my_number=3.14)
    print(d.to_data())  # Prints a JSON representation
    d1 = Demo.from_data(d.to_data())  # Clone using persistence functions
    d.save()  # Save to database
    for obj in Demo.find_all():  # Print json rep of all objects in DB
        print(obj.to_data())

Also note that currently we aren't supporting nested DBObject objects.
HOWEVER, we make no restrictions on a field being a JSON-compatible Python
type. We make it possible to supply a decent default value by allowing a
function to be specified as a default value - it will be called when a default
value is needed. For example:

    @DBObject
    class Complicated(object):
        name = Field(default='')
        complex_data = Field(default=dict)

    c = Complicate(name)
    c.complex_data['a'] = 123
    c.complex_data['b'] = 456

IMPORTANT: you should *NOT* just use a default object like this:
`Field(default={})`. Modifications made to the default object will become the
NEW default for other classes. See
[here](http://effbot.org/zone/default-values.htm)

### function `DBObject`

Classes annotated with DBObject gain persistence methods.


### function `DatabaseEnabled`

Classes annotated with DatabaseEnabled gain persistence methods. All
this really does is add some functions that forward to the mapped database
class


### class Field

Support for class-level field declaration.
    

#### function  `__init__`

 | (self, default='', indexed=False)


#### function  `get_default_val`

 | (self)
Helper to expand default value (support callables)



### function `Index`

Marks instance methods of a DBObject-decorated class as being used for
indexing. The function name is used as the index name, and the return
value is used as the index value.

Note that callables are call recursively so in theory you can return
a function which will be called to get the index value


### function `now_field`

Return a string we use for storing our date time values



## module gludb.versioning (in pkg gludb)

versioning.py

GLUDB versioning implementation

### class VersioningTypes

None

####  `DELTA_HISTORY`

str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.


####  `NONE`

str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.


####  `__init__`

Initialize self.  See help(type(self)) for accurate signature.



### function `record_diff`

Return a JSON-compatible structure capable turn the `new` record back
into the `old` record. The parameters must be structures compatible with
json.dumps *or* strings compatible with json.loads. Note that by design,
`old == record_patch(new, record_diff(old, new))`


### function `record_patch`

Return the JSON-compatible structure that results from applying the
changes in `diff` to the record `rec`. The parameters must be structures
compatible with json.dumps *or* strings compatible with json.loads. Note
that by design, `old == record_patch(new, record_diff(old, new))`



